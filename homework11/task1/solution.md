# 题解
首先一个最 trivial 的想法是直接套用博弈问题的普遍框架，按设定可以拿到30%的分数。[Code:std30.cpp]

然后我们可以给搜索加上一点记忆化，即保存之前的结果以减少重复，可以做到O(n^2), 按设定可以拿到50%分数。[Code:std50.cpp]

最后，我们可以通过之前几步的程序算出一些结果找到规律：当且仅当 p 为奇数或 2 的奇数次方时必败，否则必胜。

Lemma 1：必败态如果可以操作必转换为必胜。
1.p 为奇数，则因子 x 也必为奇数，设p = (2n + 1) * (2m + 1), x =  2m + 1， p - x = 2n * x (x > 1, x 奇数)，p - x 为非2奇数次方的偶数，必胜。
2.p 为2的奇数次方的偶数，p = 2^(2k+1), x = 2^n, n <= 2k
1)n < 2k p-x = 2^x * (2^(2k+1-x) - 1) 为非2奇数次方的偶数必胜。
2)n = 2k p-x = 2^2k 为2的偶数次方必胜。

Lemma 2: 必胜态必有操作留给对手必败态。
1.p 为2的偶数次方 p = 2^2k (k>=1), 令x = 2^(2k-1) p-x = 2^(2k-1) 必败
2.p = 2^k * m (m > 1 m奇数 k >= 1)，令x = m p-x = (2^k - 1)*m 奇数必败

结合 p=1 时必败用归纳法不难证明

可以做到O(log n)每次查询，按设定可以拿到100%[Code:std.cpp]

附带数据在trace文件夹下，附带测评脚本score.rb (内存限制未实现）